<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Human Planning - TSP</title>

  <script src="TSP_stimuli_b1_full.js"></script>
  <script src="TSP_stimuli_b2_full.js"></script>

  <!-- FileSaver for saving files -->
  <script src="https://cdn.jsdelivr.net/npm/file-saver"></script>

  <!-- JSZip for bundling puzzle logs + audio into one download -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

  <style>
    body {
      font-family: 'Segoe UI', Tahoma, sans-serif;
      background-color: #f9f9f9;
      color: #333;
      margin: 0;
      padding: 20px;
      display: flex;
      justify-content: center;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      box-sizing: border-box;
    }

    .site-footer {
      background-color: #534c4cff;
      border-top: 1px solid #ccc;
      padding: 6px 20px;
      text-align: center;
      font-size: 0.8rem;
      color: #555;
      margin-top: auto; /* pushes footer to bottom */
      width: 100%;
    }

    .footer-content {
      display: flex;
      justify-content: center;
      gap: 16px;
      flex-wrap: wrap;
    }

    .container {
      display: flex;
      flex-wrap: wrap;
      gap: 24px;
      align-items: flex-start;
      width: 100%;
      max-width: 1200px;
    }

    .left-column {
      max-width: 420px;
      flex-shrink: 1;
      background-color: #ffffff;
      padding: 16px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
      /* Remove min-height - let content determine height */
    }

    .right-column {
      max-width: 700px;
      flex-shrink: 1;
      flex: 2;
      background-color: #ffffff;
      padding: 16px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
      /* Remove min-height - let content determine height */
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      align-items: center;
    }

    /* Countdown badge shown during trials */
    .trial-timer {
      align-self: flex-end;
      margin-bottom: 8px;
      padding: 6px 12px;
      border-radius: 9999px;
      border: 1px solid #a5d6a7;   /* soft green border */
      background: #e8f5e9;         /* soft green bg */
      color: #1b5e20;              /* deep green text */
      font-weight: 600;
      font-size: 20px;
      letter-spacing: .5px;
      font-variant-numeric: tabular-nums;
    }
    .trial-timer.warning {
      border: 1px solid #ffe082;   /* soft amber border */
      background: #fff8e1;         /* gentle yellow bg */
      color: #8d6e63;              /* warm brown text */
      transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease;
    }
    .trial-timer.urgent {
      background: #ffebee;
      border-color: #ef9a9a;
      color: #b71c1c;
    }

    .reveal-total-btn{
      background:#42a5f5; color:#fff; border:none; border-radius:6px;
      padding:6px 10px; cursor:pointer; font-size:0.9rem;
    }
    .reveal-total-btn:hover{ background:#42a5f5; }

    /* Optional: dim a frozen row and show a locked button state */
    .candidate-row.is-frozen { opacity: 0.75; }
    .reveal-total-btn.locked { cursor: not-allowed; filter: grayscale(1); }

    .final-pick {
      appearance: none;
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      border: 2px solid #42a5f5;
      display: inline-block;
      position: relative;
      cursor: pointer;
    }

    .final-pick:checked::after {
      content: "";
      position: absolute;
      top: 50%;
      left: 50%;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #42a5f5;
      transform: translate(-50%, -50%);
    }

    .rules-text {
      border-left: 6px solid #42a5f5;
      font-size: 0.95rem;
      padding-left: 12px;
      margin-bottom: 20px;
    }

    .state-display { /* retained for non-trial screens */
      font-size: 16px;
      margin: 12px 0;
      background-color: #f4faff;
      padding: 10px 12px;
      border-radius: 6px;
      border-left: 4px solid #42a5f5;
    }

    .done-button {
      font-size: 14px;
      padding: 10px 18px;
      border: none;
      border-radius: 6px;
      background-color: #42a5f5;
      color: white;
      cursor: pointer;
      transition: background-color 0.2s ease;
    }
    .done-button:hover { background-color: #1e88e5; }

    .center { text-align: center; }

    /* Intro, instructions, error, end screens */
    #intro-screen, #instructions-screen, #end-screen {
      max-width: 600px;
      background-color: #ffffff;
      padding: 24px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
      display: none;
    }

    #end-screen { text-align: center; }

    #error-message {
      display: none;
      max-width: 600px;
      color: #B00020;
      background-color: #ffe6e6;
      padding: 12px 16px;
      margin-bottom: 20px;
      border-radius: 8px;
      text-align: center;
      border: 1px solid #F44336;
    }

    .path-grid{
      display:grid;
      grid-template-columns: auto repeat(9, minmax(0,1fr)) auto; /* label | S1 D1 S2 D2 S3 D3 S4 D4 S5 | total */
      column-gap:12px;
      row-gap:10px;
      align-items:center;
    }
    .cand-distance-input{
      width:40px;
      text-align:center;
      justify-self:center;
    }

    /* Add to your <style> */
    .table-matrix {
      border-collapse: collapse;
      margin-top: 12px;
    }
    .table-matrix caption {
      font-weight: 600;
      margin-bottom: 6px;
    }
    .table-matrix th, .table-matrix td {
      border: 1px solid #cfd8dc;
      padding: 6px 8px;
      text-align: center;
    }
    .table-matrix th {
      background: #f4faff;
    }
    .table-matrix .diag {
      color: #9e9e9e;
      background: #fafafa;
    }

    /* --- Compact candidate rows so they never overlap the Sum box --- */
    .right-column #candidate-list, 
    .right-column #candidate-list .candidate-row,
    .right-column #candidate-list .path-grid {
      width: 100%; /* keep rows inside the right column’s width */
    }

    /* KEY: allow all grid children to shrink with the track */
    .right-column #candidate-list .path-grid > * { 
      min-width: 0; 
    }

    /* Override hardcoded inline widths on selects/inputs */
    .right-column #candidate-list .candidate-select,
    .right-column #candidate-list .cand-distance-input {
      width: 100% !important;  /* fill the grid track, not a fixed pixel width */
      min-width: 0;            /* actually allow shrinking */
    }

    /* Tighten the grid only inside candidate rows */
    .right-column #candidate-list .path-grid {
      column-gap: 4px;   /* was 12px in the base .path-grid */
      row-gap: 6px;      /* a bit tighter for 5–6 cities */
      font-size: 0.85rem;/* optional: slightly more compact controls */
    }

    /* Make the Sum controls compact so the last column stays slim */
    .right-column #candidate-list .cand-distance-wrap .reveal-total-btn {
      padding: 4px 6px;
      font-size: 0.85rem;
    }
    .right-column #candidate-list .cand-distance-wrap input[id$='-distance'] {
      width: 28px; /* small but readable */
    }

  </style>
</head>
<body>

  <!-- Inline error message (replaces native alerts) -->
  <div id="error-message"></div>

  <!-- Container for transient voice prompt banner (inserted dynamically) -->
  <!-- <div id="prompt-message"></div> created by ensurePromptBanner() -->

  <!-- Container for the multi-step intro screens -->
  <div id="intro-screen"></div>

  <!-- Container for per-block instructions -->
  <div id="instructions-screen"></div>

  <!-- The main task UI (blank left/right columns during trials) -->
  <div id="task-ui" class="container" style="display: none;"></div>

  <!-- The final end screen -->
  <div id="end-screen">
    <p style="margin-bottom: 24px; font-size: 18px;">
      The study is now complete.<br>
      Press any key to receive payment.
    </p>
  </div>

  <script type="module">
    // --------------------------------------
    // GLOBAL CONFIG
    // --------------------------------------
    const N = 5; // N problems per block

    // --- Within-block rest config ---
    const INBLOCK_REST_AFTER = 3;   // <-- set your i here (e.g., 2 means: rest after 2 trials)
    const inBlockRestShown = { block1: false, block2: false }; // one rest per block


    // Randomly sample starting states
    function getRandomIndices(len, exclude = [], count = 5) {
      const idxs = [];
      while (idxs.length < count) {
        const i = Math.floor(Math.random() * len);
        if (!idxs.includes(i) && !exclude.includes(i)) idxs.push(i);
      }
      return idxs;
    }

    const Block1 = Array.from({ length: N }, () => ({}));
    const Block2 = Array.from({ length: N }, () => ({}));

    // Decide order of blocks randomly
    const blocks = ['block1','block2'];
    const blockData = { block1: Block1, block2: Block2 };

    let blockIndex = 0; // which block (0 or 1)
    let trialIndex = 0; // which trial (0..N-1)

    // Build per-block random prompts (N per block) from the correct stimulus set
    const block1Prompts   = buildPromptsWithConstraints(TSP_STIMULI_B1, N);
    const block2Prompts = buildPromptsWithConstraints(TSP_STIMULI_B2, N);
    let currentPrompt = null;
    const promptData = { block1: block1Prompts, block2: block2Prompts };

    // puzzle state and logs
    let currentState = {};
    let userActions = [];
    let allProblemLogs = [];


    // participant info
    let participantData = { agreement:'', gender:'', age:'', languages:'', languageDetails:'' };

    // problem start timestamp
    let problemStartTime = null;


    // --------------------------------------
    // FIREBASE CONFIGURATION
    // --------------------------------------
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
    import { getFirestore, collection, addDoc, serverTimestamp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';
    import { getStorage, ref, uploadBytes } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-storage.js';

    const firebaseConfig = {
      apiKey: "AIzaSyBmwVKrctSe5uCf_mUk0fX98PU0bfBfZ_k",
      authDomain: "tsp-experiment-storage.firebaseapp.com",
      projectId: "tsp-experiment-storage",
      storageBucket: "tsp-experiment-storage.firebasestorage.app",
      messagingSenderId: "705114542213",
      appId: "1:705114542213:web:c08d81670f40055ff5d9ec",
      measurementId: "G-64EMG37V4C"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const storage = getStorage(app);
    // --------------------------------------
    // HELPERS
    // --------------------------------------

    function showError(msg) {
      const err = document.getElementById('error-message');
      err.textContent = msg;
      err.style.display = 'block';
      setTimeout(() => err.style.display = 'none', 3000);
    }

    function renderDistanceTable(hostEl, cities, matrix) {
      const n = cities.length;

      let html = `<table class="table-matrix" aria-label="Full distance matrix">
        <thead>
          <tr>
            <th></th>${cities.map(c => `<th>${c}</th>`).join('')}
          </tr>
        </thead>
        <tbody>`;

      for (let i = 0; i < n; i++) {
        html += `<tr><th scope="row">${cities[i]}</th>`;
        for (let j = 0; j < n; j++) {
          const isDiag = i === j;
          const val = matrix?.[i]?.[j] ?? '';
          html += `<td class="${isDiag ? 'diag' : ''}">${isDiag ? '—' : val}</td>`;
          // If you prefer 0s on the diagonal, use:  ${val}  instead of '—'
        }
        html += `</tr>`;
      }

      html += `</tbody></table>`;
      hostEl.insertAdjacentHTML("beforeend", html);
    }


    // Build a prompt list with constraints… 
    function buildPromptsWithConstraints(stimuli, N) {
      // Shuffle a working copy
      const pool = stimuli.slice();
      for (let i = pool.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [pool[i], pool[j]] = [pool[j], pool[i]];
      }

      // Bucket by cities length
      const bySize = { 4: [], 5: [], 6: [] };
      pool.forEach(s => {
        const n = s?.cities?.length;
        if (bySize[n]) bySize[n].push(s);
      });

      const out = [];

      const removeFrom = (size, stim) => {
        const arr = bySize[size];
        if (!arr) return;
        const idx = arr.indexOf(stim);
        if (idx > -1) arr.splice(idx, 1);
      };

      const takeOneFromSizes = (sizes) => {
        const bag = [];
        sizes.forEach(sz => { if (bySize[sz]?.length) bag.push(...bySize[sz]); });
        if (!bag.length) return null;
        const chosen = bag[Math.floor(Math.random() * bag.length)];
        removeFrom(chosen.cities.length, chosen);
        return chosen;
      };

      // 1) First trial must have 4 cities
      let pick = takeOneFromSizes([4]);
      if (!pick) { console.warn("No 3-node for first trial; relaxing."); pick = takeOneFromSizes([5, 6]); }
      if (pick) out.push(pick);

      // 2) Second trial must have 4 or 5 cities
      pick = takeOneFromSizes([4, 5]);
      if (!pick) { console.warn("No 4-node for second trial; relaxing."); pick = takeOneFromSizes([6]); }
      if (pick) out.push(pick);

      // 3) While filling the rest, enforce:
      //    - No two consecutive 5s
      //    - If sequence is 5-6 or 6-5, next must be 4
      while (out.length < Math.min(N, stimuli.length)) {
        const prev = out[out.length - 2]?.cities?.length ?? null;
        const last = out[out.length - 1]?.cities?.length ?? null;

        // Rule: if we have 5-6 or 6-5, next must be 4 (hard try)
        const forceNextIs4 = (prev === 5 && last === 6) || (prev === 6 && last === 5);

        pick = null;

        if (forceNextIs4) {
          pick = takeOneFromSizes([4]);
          if (!pick) {
            console.warn("No 4-node available after a 5-6/6-5 sequence; relaxing to other allowed sizes.");
          }
        }

        if (!pick) {
          // Start with all sizes
          let allowed = [4, 5, 6];

          // 3) No two consecutive 5s
          if (last === 6) allowed = allowed.filter(s => s !== 6);

          // Try to pick from allowed
          pick = takeOneFromSizes(allowed);

          // Final relax if pool is tight
          if (!pick) pick = takeOneFromSizes([4, 5, 6]);
          if (!pick) break;
        }

        out.push(pick);
      }

      return out.slice(0, N);
    }

    // Replace your current readCandidatePathsFromUI with this:
    function readCandidatePathsFromUI() {
      const root = document.getElementById('task-ui');
      if (!root) return [];

      const rows = root.querySelectorAll('#candidate-list .candidate-row');
      const result = [];

      rows.forEach((row, i) => {
        const index = Number(row.dataset.index || i + 1);

        // Path (selects)
        const selects = row.querySelectorAll('.candidate-select');
        const path = Array.from(selects, s => (s.value || ""));

        // Per-hop distances (inputs between selects)
        const segmentDistances = Array.from(
          row.querySelectorAll('.cand-distance-input'),
          inp => {
            const v = (inp.value || "").trim();
            const n = Number(v);
            return v === "" || Number.isNaN(n) ? null : n; // keep nulls for missing cells
          }
        );

        // Row total (the "Sum" field)
        const distEl = row.querySelector("input[id$='-distance']");
        const totalDistance = distEl && distEl.value ? Number(distEl.value) : null;

        const sumCapturedAt = row.dataset.sumCapturedAt ? Number(row.dataset.sumCapturedAt) : null;

        // Keep rows that have any content
        const hasSegments = segmentDistances.some(d => d !== null);
        if (path.some(v => v !== "") || hasSegments || totalDistance !== null) {
          result.push({ index, path, segmentDistances, totalDistance, sumCapturedAt });
        }
      });

      return result;
    }

    // Replace your current readFinalPickFromUI with this:
    function readFinalPickFromUI() {
      const root = document.getElementById('task-ui');
      if (!root) return null;

      const pick = root.querySelector('#candidate-list .final-pick:checked');
      if (!pick) return null;

      const row = pick.closest('.candidate-row');
      if (!row) return null;

      const selects = row.querySelectorAll('.candidate-select');
      const path = Array.from(selects, s => (s.value || ""));

      const segmentDistances = Array.from(
        row.querySelectorAll('.cand-distance-input'),
        inp => {
          const v = (inp.value || "").trim();
          const n = Number(v);
          return v === "" || Number.isNaN(n) ? null : n;
        }
      );

      const distEl = row.querySelector("input[id$='-distance']");
      const totalDistance = distEl && distEl.value ? Number(distEl.value) : null;

      return {
        index: Number(row.dataset.index),
        path,
        segmentDistances,
        totalDistance
      };
    }


    function attachAutoSumForCandidateRow(
      rowEl,
      totalSelector = "input[id$='-distance']",
      inputsSelector = ".cand-distance-input"
    ) {
      const total = rowEl.querySelector(totalSelector);
      const inputs = rowEl.querySelectorAll(inputsSelector);
      if (!total || inputs.length === 0) return;

      // Ensure the gray "Compute\nSum" button exists (replaces label if present)
      const wrap = total.closest(".cand-distance-wrap");
      let revealBtn = wrap && wrap.querySelector(".reveal-total-btn");
      if (wrap && !revealBtn) {
        const oldLabel = wrap.querySelector("label");
        if (oldLabel) oldLabel.remove();
        revealBtn = document.createElement("button");
        revealBtn.type = "button";
        revealBtn.className = "reveal-total-btn";
        revealBtn.textContent = "Sum";
        revealBtn.style.whiteSpace = "pre-line"; // render \n as line break
        revealBtn.setAttribute("aria-controls", total.id || "");
        wrap.insertBefore(revealBtn, total);
      }


      // Find (or create) the final-pick radio inside the path label
      let pick = rowEl.querySelector(".final-pick");
      if (!pick) {
        const label = rowEl.querySelector(".path-label");
        if (label) {
          label.style.display = "inline-flex";
          label.style.alignItems = "center";
          label.style.gap = "8px";
          pick = document.createElement("input");
          pick.type = "radio";
          pick.className = "final-pick";
          pick.disabled = true;
          const m = (label.textContent || "").match(/\d+/);
          pick.value = m ? m[0] : "";
          pick.setAttribute("aria-label", `Choose ${label.textContent || "this Path"}`);
          pick.style.display = "none";
          label.prepend(pick);
        }
      }
      const getFinalPickGroupName = () => {
        const scope = rowEl.closest("[data-trial-id]") || rowEl.closest("#candidate-list") || document.body;
        if (!scope.dataset.finalPickGroup) {
          scope.dataset.finalPickGroup = "finalPick-" + (scope.id || Math.random().toString(36).slice(2));
        }
        return scope.dataset.finalPickGroup;
      };
      if (pick) pick.name = getFinalPickGroupName();
      
      // Prepare total (kept enabled so it can submit)
      total.readOnly = true;
      total.placeholder = "—";
      total.value = "";
      total.setAttribute("aria-live", "polite");

      const clamp1to10 = (val) => {
        if (val === "") return "";
        let n = parseInt(val, 10);
        if (Number.isNaN(n)) return "";
        if (n < 1) n = 1;
        if (n > 10) n = 10;
        return String(n);
      };

      const computeSum = () => {
        let sum = 0, hasAny = false;
        inputs.forEach(inp => {
          const n = parseInt(inp.value, 10);
          if (!Number.isNaN(n)) { sum += n; hasAny = true; }
        });
        return hasAny ? String(sum) : "";
      };

      // --- Your existing completion checks (unchanged) ---
      const allInputsFilled = () =>
        Array.from(inputs).every(inp => {
          const val = inp.value.trim();
          return val !== "" && !Number.isNaN(parseInt(val, 10));
        });

      const allSelectsFilled = () => {
        const selects = rowEl.querySelectorAll("select.candidate-select");
        if (selects.length === 0) return false;
        return Array.from(selects).every(sel => sel.value && sel.value.trim() !== "");
      };

      const allFieldsComplete = () => allSelectsFilled() && allInputsFilled();

      const updateButtonState = () => {
        if (rowEl.dataset.frozen === "true") return;
        if (!revealBtn) return;
        const canCompute = allFieldsComplete();
        revealBtn.disabled = !canCompute;
        if (canCompute) {
          revealBtn.style.background = "#42a5f5";
          revealBtn.style.cursor = "pointer";
          revealBtn.style.opacity = "1";
          revealBtn.title = "Click to compute sum and lock this row";
        } else {
          revealBtn.style.background = "#d0d0d0";
          revealBtn.style.cursor = "not-allowed";
          revealBtn.style.opacity = "0.6";
          revealBtn.title = "Fill in all cities and distance values before computing sum";
        }
      };

      // Freeze row: reveal radio & keep it enabled; disable the rest
      const freezeRow = () => {
        rowEl.dataset.frozen = "true";
        rowEl.classList.add("is-frozen");

        // Show + enable radio for finalized path
        if (pick) { pick.style.display = "inline-block"; pick.disabled = false; }

        rowEl.querySelectorAll("input, select, textarea, button").forEach(ctrl => {
          // keep total (readOnly) and the radio enabled
          if (ctrl === total || ctrl === pick) return;
          ctrl.disabled = true;
          ctrl.setAttribute("aria-disabled", "true");
        });

        if (revealBtn) {
          revealBtn.classList.add("locked");
          revealBtn.textContent = "Sum";
          revealBtn.setAttribute("aria-pressed", "true");
          revealBtn.style.background = "#7e7e7e";
          revealBtn.style.cursor = "not-allowed";
          revealBtn.style.opacity = "0.75";
        }

        // Notify outer logic if you want to gate Done/Continue elsewhere
        rowEl.dispatchEvent(new CustomEvent("rowfrozen", { bubbles: true }));
      };

      // Sanitize inputs + keep the button state in sync
      inputs.forEach(inp => {
        inp.addEventListener("keypress", (e) => { if (!/[0-9]/.test(e.key)) e.preventDefault(); });
        inp.addEventListener("input", (e) => {
          const cleaned = e.target.value.replace(/[^\d]/g, "");
          e.target.value = clamp1to10(cleaned);
          updateButtonState();
        });
        inp.addEventListener("change", (e) => {
          e.target.value = clamp1to10(e.target.value);
          updateButtonState();
        });
      });

      // Hook up select changes + timestamped logging (user-initiated only)
      setTimeout(() => {
        const selects = rowEl.querySelectorAll("select.candidate-select");

        // Initialize prev cache only; DO NOT push any initial logs
        selects.forEach(sel => { sel.dataset.prev = sel.value || ""; });

        selects.forEach((sel, idx) => {
          sel.addEventListener("focus", (e) => {
            e.target.dataset.prev = e.target.value || "";
          }, true);

          sel.addEventListener("change", (e) => {
            // Skip fixed dropdowns: disabled, data-fixed, class 'fixed', or first/last in the path
            const isFixed = sel.disabled
              || sel.dataset.fixed === "true"
              || sel.classList.contains("fixed")
              || idx === 0
              || idx === selects.length - 1;

            if (isFixed) {
              e.target.dataset.prev = e.target.value || "";
              updateButtonState();
              return;
            }

            // Ignore programmatic changes (only log user actions)
            if (!e.isTrusted) {
              e.target.dataset.prev = e.target.value || "";
              updateButtonState();
              return;
            }

            const prev = e.target.dataset.prev || "";
            const next = e.target.value || "";
            if (typeof trialActive !== "undefined" && trialActive && prev !== next) {
              try {
                userActions.push({
                  type: "select-action",
                  action: (prev === "" ? "initial" : "block2"),
                  candidateIndex: Number(rowEl.dataset.index),
                  pathTag: `candidate-${rowEl.dataset.index}`,
                  selectId: e.target.id || null,
                  selectPosition: idx + 1,
                  from: prev,
                  to: next,
                  blockType: (typeof blocks !== "undefined" ? blocks[blockIndex] : null),
                  trialIndex: (typeof trialIndex !== "undefined" ? trialIndex + 1 : null),
                  timestamp: Date.now()
                });
              } catch (_) {}
            }
            e.target.dataset.prev = next;
            updateButtonState();
          });
        });

        // ---- Distance logging (entry + change) ----
        const distInputs = rowEl.querySelectorAll(".cand-distance-input");

        distInputs.forEach((inp, idx) => {
          // Seed cache only—do NOT log initial state
          inp.dataset.prev = inp.value || "";

          const logDistance = (e) => {
            // Only during real trials; ignore non-user events
            if (!(typeof trialActive !== "undefined" && trialActive)) return;
            if (e && e.isTrusted === false) { inp.dataset.prev = inp.value || ""; return; }

            const prev = inp.dataset.prev || "";
            const next = inp.value || "";

            if (prev === next) return; // nothing changed

            try {
              userActions.push({
                type: "distance-action",
                action: (prev === "" ? "entry" : "block2"),
                candidateIndex: Number(rowEl.dataset.index),
                pathTag: `candidate-${rowEl.dataset.index}`,
                segmentPosition: idx + 1,
                from: prev,
                to: next,
                blockType: (typeof blocks !== "undefined" ? blocks[blockIndex] : null),
                trialIndex: (typeof trialIndex !== "undefined" ? trialIndex + 1 : null),
                timestamp: Date.now()
              });
            } catch (_) {}

            inp.dataset.prev = next;
          };

          // Log when the user commits the value
          inp.addEventListener("change", logDistance);
          inp.addEventListener("blur", logDistance, true);
          inp.addEventListener("keydown", (e) => { if (e.key === "Enter") logDistance(e); });
        });

        // ---- Final pick logging (selection + change) ----
        (() => {
          // One shared place to remember the previously selected candidate for this trial
          const root = rowEl.closest("[data-candidates]") || document.body;

          // Support either a class or a name for the final-pick radios
          const finalPickRadio = rowEl.querySelector(
            "input[type='radio'].final-pick, input[type='radio'][name='final-pick']"
          );
          if (!finalPickRadio) return;

          // Seed previous value without logging (so defaults don't create entries)
          if (finalPickRadio.checked && !root.dataset.finalPickPrev) {
            root.dataset.finalPickPrev = String(rowEl.dataset.index);
          }

          finalPickRadio.addEventListener("change", (e) => {
            // Only during block1/block2 and only user-triggered
            if (!(typeof trialActive !== "undefined" && trialActive)) return;
            if (e.isTrusted === false) return;

            const prev = root.dataset.finalPickPrev ?? "";
            const next = String(rowEl.dataset.index);
            if (prev === next) return;

            const now = Date.now();

            try {
              userActions.push({
                type: "select-final",
                action: (prev === "" ? "initial" : "block2"),
                // From/to (indices) so you can reconstruct the history
                fromIndex: (prev === "" ? null : Number(prev)),
                toIndex: Number(next),
                // Path tags (both sides) for easy filtering
                fromPathTag: (prev === "" ? null : `candidate-${prev}`),
                toPathTag: `candidate-${next}`,
                candidateIndex: Number(rowEl.dataset.index), // same as toIndex; kept for consistency
                blockType: (typeof blocks !== "undefined" ? blocks[blockIndex] : null),
                trialIndex: (typeof trialIndex !== "undefined" ? trialIndex + 1 : null),
                timestamp: now
              });
            } catch (_) {}

            // Update previous selection
            root.dataset.finalPickPrev = next;
          });
        })();

        updateButtonState(); // initial state
      }, 0);



      // Click to compute (only if complete) and then lock
      if (revealBtn) {
        revealBtn.addEventListener("click", (e) => {
          e.preventDefault();
          if (rowEl.dataset.frozen === "true") return;
          if (!allFieldsComplete()) return;
          total.value = computeSum();
          total.dispatchEvent(new Event("input", { bubbles: true }));
          
          const sumTs = Date.now();
          rowEl.dataset.sumCapturedAt = String(sumTs);

          freezeRow();
        }, { once: true });
      }
    }

    // ---- Trial timer (4-minute limit) ----
    let countdownInterval = null;
    let countdownDeadline = 0;
    let trialActive = false; // guards against double-ending

    function formatClock(ms) {
      const total = Math.ceil(ms / 1000);
      const m = Math.max(0, Math.floor(total / 60));
      const s = Math.max(0, total % 60);
      return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
    }

    function updateTimerDisplay() {
      const el = document.getElementById('trial-timer');
      if (!el) return;

      const remaining = Math.max(0, countdownDeadline - Date.now());
      el.textContent = formatClock(remaining);

      const secs = Math.ceil(remaining / 1000);

      // urgent beats warning (<=10s)
      el.classList.toggle('urgent',  secs <= URGENT_THRESHOLD_S);
      el.classList.toggle('warning', secs >  URGENT_THRESHOLD_S && secs <= WARNING_THRESHOLD_S);

      if (remaining <= 0) {
        clearTrialTimer();
        if (!advanceOnSurveyTimeout()) {
          endTrial('timeout');
        }
      }
    }

    // Map number of cities to seconds 
    function getTrialLimitMsFromCities(count) {
      const secsByCities = { 4: 240, 5: 300, 6: 360 }; // seconds
      const seconds = secsByCities[count] ?? 15;   // fallback
      return seconds * 1000;
    }

    function startTrialTimer(limitMs) {
      if (typeof limitMs !== 'number') throw new Error('startTrialTimer requires limitMs');
      clearTrialTimer();
      countdownDeadline = Date.now() + limitMs;

      const el = document.getElementById('trial-timer');
      if (el) el.classList.remove('urgent', 'warning');

      updateTimerDisplay();
      countdownInterval = setInterval(updateTimerDisplay, 250);
    }

    const WARNING_THRESHOLD_S = 20; // turn yellow at <= 60s
    const URGENT_THRESHOLD_S  = 10; // turn red at <= 10s

    function clearTrialTimer() {
      if (countdownInterval) {
        clearInterval(countdownInterval);
        countdownInterval = null;
      }
    }

    // ---- Final Survey globals & helpers ----
    let finalSurveyData = null;

    function ensureStyle(id, css) {
      let el = document.getElementById(id);
      if (!el) {
        el = document.createElement('style');
        el.id = id;
        document.head.appendChild(el);
      }
      el.textContent = css;
    }
    function removeStyle(id) {
      const el = document.getElementById(id);
      if (el && el.parentNode) el.parentNode.removeChild(el);
    }

    function addBaseSurveyStyles() {
      ensureStyle('survey-base-css', `
        .survey-container { max-width: 1000px; margin: 0 auto; padding: 16px; }
        .survey-title { text-align: center; margin-bottom: 16px; }
        .survey-subtitle { text-align: center }
        .survey-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; align-items: start; }
        .survey-col { display: grid; gap: 8px; }
        .q-row {
          display: grid;
          grid-template-columns: 1.2fr 1fr; /* left question / right controls */
          gap: 12px; align-items: center; padding: 8px 10px;
          border: 1px solid #ddd; border-radius: 8px; background: #fafafa;
        }
        .q-text { font-size: 14px; line-height: 1.3; }
        .likert { display: flex; justify-content: space-between; gap: 6px; }
        .likert-btn {
          min-width: 36px; min-height: 32px; border: 1px solid #bbb; border-radius: 6px;
          background: white; cursor: pointer; font-size: 14px;
        }
        .likert-btn.selected, .likert-btn[aria-pressed="true"] {
          outline: none; border-color: #222; background: #eaeaea; font-weight: 600;
        }
        .survey-key { text-align: center; margin: 20px 0 10px; font-size: 14px; }
        .survey-actions { display: flex; justify-content: center; margin-top: 8px; }
        #survey-submit[disabled] { opacity: .6; cursor: not-allowed; }

        #instructions-screen.wide { max-width: 1100px; width: min(1100px, 95vw); }

        /* shared width rules for textareas used in both screens */
        #final-survey .survey-col textarea.survey-text,
        #pre-final-survey textarea.survey-text,
        .notes-textarea,
        .practice-textarea {
          width: 100%; max-width: none; min-width: 0; box-sizing: border-box;
        }
      `);
    }

    function likertRowHtml(qid, label) {
      const btn = v => `<button type="button" class="likert-btn" data-q="${qid}" data-value="${v}" aria-pressed="false">${v}</button>`;
      return `
        <div class="q-row">
          <div style="text-align:left;"><strong>${label}</strong></div>
          <div class="likert" role="group" aria-label="${qid} Likert scale">
            ${[1,2,3,4,5].map(btn).join('')}
          </div>
        </div>
      `;
    }

    // Pre-final survey only 
    function addPreFinalSurveyStyles() {
      addBaseSurveyStyles();
      removeStyle('final-survey-css'); // keep head lean when switching
      ensureStyle('pre-final-survey-css', `
        /* keep the survey centered and prevent overflow */
        #pre-final-survey.survey-container { max-width: 1100px; width: 100%; margin: 0 auto; }
        #pre-final-survey .survey-grid { grid-template-columns: minmax(0,1fr) minmax(0,1fr); }
        #pre-final-survey .survey-col,
        #pre-final-survey .q-row,
        #pre-final-survey .q-row > * { min-width: 0; }

        /* tighter Likert buttons */
        #pre-final-survey .likert { width: max-content; justify-content: flex-start; gap: 4px; flex-wrap: nowrap; }
        #pre-final-survey .likert-btn { 
          flex: 0 0 auto; min-width: 26px; height: 26px; padding: 0 6px;
          font-size: 12px; line-height: 26px; border-radius: 4px; margin: 0; 
        }

        /* base split: left question, right buttons */
        #pre-final-survey .q-row {
          grid-template-columns: 1fr auto; /* auto shrinks right col to fit buttons */
          gap: 8px; /* smaller gap between question text and buttons */
        }

        /* override when a textarea is present */
        #pre-final-survey .q-row:has(textarea.survey-text) {
          grid-template-columns: 1.2fr auto;
        }
      `);
    }

    // Final survey only
    function addFinalSurveyStyles() {
      addBaseSurveyStyles();
      removeStyle('pre-final-survey-css'); // if you had pre-survey styles
      ensureStyle('final-survey-css', `
        #final-survey .survey-grid { grid-template-columns: 1fr; justify-items: center; }
        #final-survey .survey-col { width: min(820px, 95vw); max-width: 820px; margin: 0 auto; }
        #final-survey .survey-actions { justify-content: center; }
        #final-survey .q-row { grid-template-columns: 1fr; text-align: center; }
        #final-survey .likert { justify-content: center; gap: 10px; }
        #final-survey .survey-key { text-align: center; color:#666; font-size:.9rem; }
        #final-survey textarea.survey-text { display:block; margin:8px auto 12px; width:100%; box-sizing:border-box; resize:none !important; overflow:auto; }
      `);
    }

    function showInternalImagerySurvey() {
      // Reuse the base styles you already have
      if (typeof addBaseSurveyStyles === 'function') addBaseSurveyStyles();

      const mount = document.getElementById('instructions-screen');
      mount.style.display = 'block';
      mount.classList.add('wide');
      document.getElementById('task-ui').style.display = 'none';

      // 12 items (your prompt)
      const questions = [
        'I think about problems in my mind in the form of a conversation with myself',
        'If I am walking somewhere by myself, I frequently think of conversations that I’ve recently had',
        'When I read, I tend to hear a voice in my "mind’s ear"',
        'I like to give myself some down time to talk through thoughts in my mind',
        'I often talk to myself internally while watching TV',
        'My inner speech helps my imagination',
        'When thinking about a social problem, I often talk it through in my head',
        'My memories often involve conversations I’ve had',
        'I rarely vocalize thoughts in my mind',
        'If I am walking somewhere by myself, I often have a silent conversation with myself',
        'I tend to think things through verbally when I am relaxing',
        'I hear words in my "mind’s ear" when I think'
      ];

      const leftQs = questions.slice(0, 6);
      const rightQs = questions.slice(6);

      const colHtml = (labels, colId, startIndex) => `
        <div class="survey-col" id="${colId}">
          ${labels.map((label, idx) => `
            <div class="q-row" data-qid="${colId}-${startIndex + idx + 1}">
              <div class="q-text"><strong>${startIndex + idx + 1}. ${label}</strong></div>
              <div class="likert" role="group" aria-label="${label}">
                ${[1,2,3,4,5].map(v => `
                  <button type="button" class="likert-btn" data-val="${v}" aria-pressed="false">${v}</button>
                `).join('')}
              </div>
            </div>
          `).join('')}
        </div>
      `;

      mount.innerHTML = `
        <div id="internal-imagery-survey" class="survey-container">
        <div id="trial-timer" class="trial-timer" aria-live="polite">05:00</div>
          <h2 class="survey-title">Survey 1: Thinking Styles</h2>
          <h3 class="survey-subtitle">Please answer all 12 statements.</h3>
          <div class="survey-grid">
            ${colHtml(leftQs, 'iis-col1', 0)}
            ${colHtml(rightQs, 'iis-col2', 6)}
          </div>
          <div class="survey-key">
            <strong>Scale:</strong>
            1 (Totally Disagree) · 2 (Somewhat Disagree) · 3 (Neutral) ·
            4 (Somewhat Agree) · 5 (Totally Agree)
          </div>
          <div class="survey-actions">
            <button id="survey-submit" disabled>Continue</button>
          </div>
        </div>
      `;

      startTrialTimer(5 * 60 * 1000);

      const responses = {};
      const submitBtn = document.getElementById('survey-submit');
      const allButtons = mount.querySelectorAll('#internal-imagery-survey .likert-btn');

      function updateSubmitState() {
        submitBtn.disabled = Object.keys(responses).length < 12;
      }

      allButtons.forEach((btn) => {
        btn.addEventListener('click', () => {
          const row = btn.closest('.q-row');
          const qid = row.dataset.qid;
          row.querySelectorAll('.likert-btn').forEach((b) => {
            b.setAttribute('aria-pressed', 'false');
            b.classList.remove('selected');
          });
          btn.setAttribute('aria-pressed', 'true');
          btn.classList.add('selected');
          responses[qid] = Number(btn.dataset.val);
          updateSubmitState();
        });
      });
      submitBtn.addEventListener('click', () => {
        clearTrialTimer();
        const completedAt = Date.now();
        window.internalImagerySurvey = {
          type: 'internal-imagery-survey',
          responses: { ...responses },   // <-- the real answers (1–5 numbers)
        };
        showPreFinalSurvey();
      });
    }

    function showPreFinalSurvey() {
      addPreFinalSurveyStyles();

      const mount = document.getElementById('instructions-screen');
      mount.style.display = 'block';
      mount.classList.add('wide');
      document.getElementById('task-ui').style.display = 'none';

      // Anchor page content to the top while the pre-final survey is showing
      document.body.classList.add('pre-final-scroll');
      ensureStyle('pre-final-internal-scroll-css', `
        /* Let the instructions/survey panel scroll if it's taller than the viewport */
        #instructions-screen.wide {
          max-height: calc(100vh - 100px);
          overflow-y: auto;
          -webkit-overflow-scrolling: touch;
        }

        /* Keep the timer visible while the user scrolls the survey */
        #pre-final-timer { position: sticky; top: 8px; }
      `);


      // ✅ Your custom text
      const questions = ['When I navigate, I pay attention to the landmarks at the turning points and try to remember their sequence.', 
      'I have navigational intuition.', "I can easily point to a specific place outside the building when I don't see it from the inside.", 
      'I can find my way under low visibility conditions (or even in darkness) in familiar places better than other people', 
      'I rely primarily on a schematic mental representation of my environment to figure out my position in the environment.', 
      'My mental representation of the route that I traversed is analogous to a schematic map (e.g., floor-plan, blue-print, metro map) rather than a first-person perspective of routes and landmarks.', 
      'To avoid getting lost, I usually try to memorize the landmarks around me, along with their associated turns.', 'I have an “internal compass”', 
      'I usually attempt to mentally represent route segments, turns and their spatial relationships from a topdown aerial perspective.', 
      'I usually attempt to visualize a map of the environment from a top-down aerial perspective as I travel.', 
      'At any time during a route, I can point back to the landmarks I have passed by.', 
      'I rely primarily on a schematic mental representation of my environment to help me in finding shortcuts.', 
      'I can plan out my route of travel by visualizing a schematic map from a top-down aerial perspective.', 
      'To reach my destination, I largely recruit a set of procedures telling me the actions to perform (i.e., go straight/back, turn left/right) at different locations on my route.', 
      'I rely primarily on landmarks as signs of turning points along my route of travel.', 'I keep a mental record of the landmarks I see on my traveling route in a sequential fashion.', 
      'If I were to walk on my route again, I would depend heavily on a sequence of mental “snapshots” of landmarks or scenes to go to the places I had been to.', 
      'In an unfamiliar environment with no clear landmarks (e.g., forest, desert, new city) and/or in low visibility conditions (e.g., fog, heavy rain), I still have a good sense of where I am heading.'];

      const leftQs = questions.slice(0, 9);  // Q1–Q5
      const rightQs = questions.slice(9);    // Q6–Q10

      const colHtml = (labels, colId, startIndex) => `
        <div class="survey-col" id="${colId}">
          ${labels.map((label, idx) =>
            likertRowHtml(`${colId}-${startIndex + idx + 1}`,
              `${startIndex + idx + 1}. ${label}`)
          ).join('')}
        </div>
      `;

      mount.innerHTML = `
        <style>
          .survey-title {
            font-size: 20px; /* adjust size as you like */
          }
        </style>
        <style>
          .survey-subtitle {
            font-size: 16px; /* adjust size as you like */
          }
        </style>
        <div id="pre-final-survey" class="survey-container">
        <div id="trial-timer" class="trial-timer" aria-live="polite">07:00</div>

          <h2 class="survey-title">Survey 2: Navigation Styles</h2>
          <h3 class="survey-subtitle">Respond based on how you navigate the familiar places in your everyday environment (Scroll to view all questions).</h3>
          <div class="survey-grid">
            ${colHtml(leftQs, 'col1', 0)}   <!-- 1–5 -->
            ${colHtml(rightQs, 'col2', 9)}  <!-- 6–10 -->
          </div>

          <div class="survey-key">
            <strong>Scale:</strong>
            1 (Totally Disagree) · 2 (Somewhat Disagree) · 3 (Neutral) · 
            4 (Somewhat Agree) · 5 (Totally Agree)
          </div>

          <div class="survey-actions">
            <button id="survey-submit" disabled>Continue</button>
          </div>
        </div>
      `;

      const responses = {};
      const submitBtn = document.getElementById('survey-submit');
      const allButtons = mount.querySelectorAll('#pre-final-survey .likert-btn');

      function updateSubmitState() {
        submitBtn.disabled = Object.keys(responses).length < 18;
      }

      allButtons.forEach((btn) => {
        btn.addEventListener('click', () => {
          const row = btn.closest('.q-row');

          // Read qid from the button (data-q) or the row (data-qid)
          const qid = btn.dataset.q || row?.dataset.qid;

          // Toggle selected state
          row.querySelectorAll('.likert-btn').forEach((b) => {
            b.setAttribute('aria-pressed', 'false');
            b.classList.remove('selected');
          });
          btn.setAttribute('aria-pressed', 'true');
          btn.classList.add('selected');

          // Read value from data-value or (fallback) data-val
          const v = btn.dataset.value ?? btn.dataset.val;
          responses[qid] = Number(v);

          updateSubmitState(); // keeps your "length < 18" check
        });
      });

      startTrialTimer(7 * 60 * 1000);

      submitBtn.addEventListener('click', async () => {
        clearTrialTimer();
        const completedAt = Date.now();
        window.preFinalSurvey = {
          type: 'pre-final-survey',
          responses: { ...responses },   // <-- the real answers (1–5 numbers)
        };
        showFinalSurvey();
      });
    }


    function showFinalSurvey() {
      addFinalSurveyStyles();

      const mount = document.getElementById('instructions-screen');
      mount.style.display = 'block';
      mount.classList.add('wide');
      document.getElementById('task-ui').style.display = 'none';

      const questions = [
        {
          id: 'q1',
          text: 'How accurately and completely did your thinking aloud reflect your true thought processes throughout the experiment?',
          scale: '1 (Very inaccurately) · 2 (Somewhat inaccurately) · 3 (Neutral) · 4 (Somewhat accurately) · 5 (Very accurately)',
          withTextbox: true
        },
        {
          id: 'q2',
          text: 'How familiar are you with graph theory and the traveling salesman/salesperson problem?',
          scale: '1 (Not at all familiar) · 2 (Slightly familiar) · 3 (Moderately familiar) · 4 (Very familiar) · 5 (Extremely familiar)',
          withTextbox: false
        }
      ];

      const renderBlock = (q, idx) => `
        <section class="question-block">
          ${likertRowHtml(q.id, `${idx + 1}. ${q.text}`)}
          ${q.withTextbox ? `<textarea id="${q.id}-text" class="survey-text" placeholder="Provide details here…" style="resize:none"></textarea>` : ``}
          <div class="survey-key"><strong>Scale:</strong> ${q.scale}</div>
        </section>
      `;

      mount.innerHTML = `
        <div id="final-survey" class="survey-container">
          <h2 class="survey-title">Final Survey</h2>
          <div class="survey-grid">
            <div class="survey-col" id="col-single">
              ${questions.map(renderBlock).join('')}
            </div>
          </div>
          <div class="survey-actions">
            <button id="survey-submit" disabled>Submit</button>
          </div>
        </div>
      `;

      const responses = {}; // { q1: "1-5", q2: "1-5" }
      const submitBtn = document.getElementById('survey-submit');

      function checkReady() {
        const ready = ['q1','q2'].every(k => responses[k]);
        submitBtn.disabled = !ready;
      }

      mount.querySelectorAll('#final-survey .likert-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          // toggle pressed state within the group
          const q = btn.dataset.q;
          mount.querySelectorAll(`.likert-btn[data-q="${q}"]`).forEach(b => b.setAttribute('aria-pressed', 'false'));
          btn.setAttribute('aria-pressed', 'true');
          responses[q] = btn.dataset.value;
          checkReady();
        });
      });

      submitBtn.addEventListener('click', async () => {
        // lock UI
        submitBtn.disabled = true;
        submitBtn.textContent = 'Submitting...';

        finalSurveyData = {
          q1: Number(responses.q1),
          q1_text: (document.getElementById('q1-text')?.value || '').trim(),
          q2: Number(responses.q2),
          submittedAt: Date.now()
        };

        const mount = document.getElementById('instructions-screen');
        mount.style.display = 'none';
        mount.classList.remove('wide');
        mount.innerHTML = '';

        const end = document.getElementById('end-screen');
        end.style.display = 'block';
        end.setAttribute('tabindex', '-1');
        end.focus();

        // proceed to the usual end/save flow
        await finishStudy();
      });
    }

    // put this near your other helpers
    function advanceOnSurveyTimeout() {
      if (document.getElementById('internal-imagery-survey')) {
        if (typeof showPreFinalSurvey === 'function') showPreFinalSurvey();
        return true;
      }
      if (document.getElementById('pre-final-survey')) {
        if (typeof showFinalSurvey === 'function') showFinalSurvey();
        return true;
      }
      return false;
    }

    // --------------------------------------
    // AUDIO RECORDING
    // --------------------------------------
    let audioStream = null;
    let recorder = null;
    const audioChunks = []; // {block, trial, blob}

    async function requestAudioPermission() {
      try {
        audioStream = await navigator.mediaDevices.getUserMedia({ audio:true });
      } catch (e) {
        console.error(e);
        showError("Microphone access is needed to record your responses.");
      }
    }

    function startRecording(blockNum, trialNum) {
      if (!audioStream) return;
      recorder = new MediaRecorder(audioStream);
      recorder.ondataavailable = e => {
        if (e.data.size > 0) audioChunks.push({ block:blockNum, trial:trialNum, blob:e.data });
      };
      recorder.start();
    }

    function stopRecording(cb) {
      if (!recorder) { cb && cb(); return; }
      recorder.onstop = () => { cb && cb(); };
      recorder.stop();
      recorder = null;
    }

    // =============================
    // LIVE VOICE FEEDBACK MODULE (separate from saving recorder)

    function ensurePromptBanner() {
      let el = document.getElementById("prompt-message");
      if (!el) {
        el = document.createElement("div");
        el.id = "prompt-message";
        el.style.display = "none";
        el.style.maxWidth = "600px";
        el.style.margin = "0 0 20px 0";
        el.style.background = "#E3F2FD"; // light blue
        el.style.color = "#0D47A1";      // dark blue text
        el.style.border = "1px solid #90CAF9";
        el.style.borderRadius = "8px";
        el.style.padding = "12px 16px";
        el.style.textAlign = "center";
        const anchor = document.querySelector('#error-message');
        (anchor?.parentNode || document.body).insertBefore(el, anchor?.nextSibling || null);
      }
      return el;
    }

    function showPrompt(msg, ms = 4000) {
      const el = ensurePromptBanner();
      el.textContent = msg;
      el.style.display = "block";
      clearTimeout(showPrompt._t);
      showPrompt._t = setTimeout(() => (el.style.display = "none"), ms);
    }

    // ---- Live voice feedback using Web Audio API AnalyserNode ----
    const VoiceFeedback = (() => {
      let ctx = null;
      let source = null;
      let analyser = null;
      let freqData = null;
      let running = false;
      let timer = null;

      const cfg = {
        intervalSec: 20,   // check cadence (seconds)
        threshold: .0008,  // tune after pilot
        minHz: 85,
        maxHz: 255,
        fftSize: 2048,
        smoothing: 0.8,
      };

      let accum = 0;   // accumulated average over frames
      let frames = 0;  // number of frames accumulated
      let minBin = 0, maxBin = 0;

      function setupBins(sampleRate, fftSize) {
        const binHz = sampleRate / fftSize;
        minBin = Math.floor(cfg.minHz / binHz);
        maxBin = Math.ceil(cfg.maxHz / binHz);
      }

      function sampleLoop() {
        if (!running) return;
        analyser.getFloatFrequencyData(freqData); // dB values
        // Convert dB to linear magnitude and average over the speech band
        let total = 0;
        for (let i = minBin; i <= maxBin && i < freqData.length; i++) {
          total += Math.pow(10, freqData[i] / 20);
        }
        const avg = total / Math.max(1, (maxBin - minBin + 1));
        accum += avg;
        frames += 1;
        requestAnimationFrame(sampleLoop);
      }

      async function start() {
        if (running) return;
        if (!audioStream) return; // mic not granted yet
        ctx = new (window.AudioContext || window.webkitAudioContext)();
        await ctx.resume().catch(()=>{});
        source = ctx.createMediaStreamSource(audioStream);

        analyser = ctx.createAnalyser();
        analyser.fftSize = cfg.fftSize;
        analyser.smoothingTimeConstant = cfg.smoothing;

        freqData = new Float32Array(analyser.frequencyBinCount);
        source.connect(analyser);

        setupBins(ctx.sampleRate, analyser.fftSize);
        accum = 0; frames = 0; running = true;
        sampleLoop();

        timer = setInterval(() => {
          if (!running) return;
          const avgActivity = frames ? (accum / frames) : 0;
          if (avgActivity < cfg.threshold) {
            showPrompt("Please keep speaking your thoughts aloud.");
          }
          console.debug('avgActivity', avgActivity.toFixed(5));
          accum = 0; frames = 0; // reset window
        }, cfg.intervalSec * 1000);
      }

      async function stop() {
        running = false;
        clearInterval(timer);
        try { source && source.disconnect(); } catch (_) {}
        try { ctx && (await ctx.close()); } catch (_) {}
        ctx = source = analyser = null;
        freqData = null;
        accum = 0; frames = 0;
      }

      function setConfig(overrides) { Object.assign(cfg, overrides || {}); }
      return { start, stop, setConfig, cfg };
    })();


    // --------------------------------------
    // INTRO SCREENS
    // --------------------------------------
    let introIndex = 0;
    const introScreens = [
      // 0
      `
        <p>In this study, you will solve problems involving identifying the shortest path between cities.</p>
        <p>Only anonymous data without any personal information will be stored for research purposes.</p>
        <p>Audio will also be recorded while you solve the problems.</p>
        <p>The whole study will take no longer than 1 hour to complete.</p>
        <p>If you agree to participate in the study, please respond by typing something in the box provided below.</p>
        <p>Otherwise, please close the study window.</p>
        <p><input type="text" id="agreeInput" style="width: 95%;" placeholder="Type your response here..."></p>
      `,
      // 1
      `
      <p>Please provide the following information.</p>

      <p>Gender:</p>
      <p>
        <select id="genderSelect" style="width: 100%;">
          <option value="" disabled selected hidden>Select...</option>
          <option value="Male">Male</option>
          <option value="Female">Female</option>
          <option value="Nonbinary">Nonbinary</option>
          <option value="Other">Other (please specify)</option>
        </select>
      </p>
      <p id="otherGenderWrapper" style="display:none;">
        <input type="text" id="otherGenderInput" style="width: 95%;" placeholder="Please specify..." />
      </p>

      <p>Age:</p>
      <p><input type="number" id="ageInput" style="width: 95%;" placeholder="Type your age here..." /></p>

      <p>Language(s) Spoken:</p>
      <p>
        <select id="languageSelect" style="width: 100%;">
          <option value="" disabled selected hidden>Select...</option>
          <option value="Monolingual">Monolingual (English only)</option>
          <option value="Bilingual">Bilingual</option>
          <option value="Multilingual">Multilingual (more than 2 languages)</option>
        </select>
      </p>

      <p id="languageDetailsWrapper" style="display:none;">
        <label for="languageDetailsInput" style="display:block; margin-bottom:4px;">
          If you responded with bilingual, or multilingual, please list the language(s) besides English you speak, and briefly describe your level of fluency.
        <textarea id="languageDetailsInput" style="width: 95%; min-height: 70px;" placeholder="e.g., Spanish (native), Mandarin (intermediate)"></textarea>
      </p>
      `,
      // 2
      `
        <p>Please turn off any music or potential sources of distraction.</p>
        <p>The experiment will switch to full screen mode when you press the button below.</p>
        <p>Please remain in full screen mode until the experiment is complete.</p>
        <p>Microphone access will also be requested for audio recording.</p>
      `,
      // 3
      `
        <p>The experiment will consist of two blocks with the same types of problems. Each block will contain ${N} problems.</p>
        <p>Before the first block, you will be presented with instructions.</p>
        <p>You will have a brief period to rest in between the first and second blocks.</p>
        <p>Please press 'Next' to see the instructions for Block #1.</p>
      `
    ];

    function startIntro() {
      introIndex = 0;
      showIntroScreen();
    }

    function showIntroScreen() {
      const introDiv = document.getElementById('intro-screen');
      introDiv.innerHTML = introScreens[introIndex] + `
        <div style="text-align: center; margin-top: 24px;">
          <button id="introNextBtn" style="padding: 10px 20px;">Next</button>
        </div>
      `;
      introDiv.style.display = 'block';

      document.getElementById('introNextBtn').addEventListener('click', handleIntroNext);

      if (introIndex === 1) {
        // gender toggle
        const sel = document.getElementById('genderSelect');
        sel.addEventListener('change', () => {
          document.getElementById('otherGenderWrapper').style.display =
            sel.value === 'Other' ? 'block' : 'none';
        });

        // language toggle
        const langSel  = document.getElementById('languageSelect');
        const langWrap = document.getElementById('languageDetailsWrapper');
        if (langSel && langWrap) {
          langSel.addEventListener('change', () => {
            const show = langSel.value === 'Bilingual' || langSel.value === 'Multilingual';
            langWrap.style.display = show ? 'block' : 'none';
          });
        }
      }
    }

    async function handleIntroNext() {
      if (introIndex === 0) {
        const val = document.getElementById('agreeInput').value.trim();
        if (!val) { showError("Please type something to proceed."); return; }
        participantData.agreement = val;

      } else if (introIndex === 1) {
        const gSel = document.getElementById('genderSelect');
        const age = document.getElementById('ageInput').value.trim();
        const langSel = document.getElementById('languageSelect');
        const langDetails = (document.getElementById('languageDetailsInput')?.value || '').trim();

        if (!gSel.value || !age || !langSel.value) {
          showError("Please select a gender, enter your age, and choose your languages."); return;
        }

        // gender handling (unchanged)
        if (gSel.value === 'Other') {
          const spec = document.getElementById('otherGenderInput').value.trim();
          if (!spec) { showError("Please specify your gender."); return; }
          participantData.gender = spec;
        } else {
          participantData.gender = gSel.value;
        }
        participantData.age = age;

        // language handling
        if ((langSel.value === 'Bilingual' || langSel.value === 'Multilingual') && !langDetails) {
          showError("Please list the other language(s) you speak (besides English) and your fluency."); return;
        }
        participantData.languages = langSel.value;
        participantData.languageDetails = langDetails;

      } else if (introIndex === 2) {
        if (document.body.requestFullscreen) document.body.requestFullscreen();
        else if (document.documentElement.requestFullscreen) document.documentElement.requestFullscreen();
        await requestAudioPermission();
      }

      introIndex++;
      if (introIndex < introScreens.length) {
        showIntroScreen();
      } else {
        document.getElementById('intro-screen').style.display = 'none';
        loadBlock();
      }
    }

    // --------------------------------------
    // PER-BLOCK INSTRUCTIONS
    // --------------------------------------
    function loadBlock() {
      const blockNum = blockIndex + 1;
      const blockType = blocks[blockIndex];
      if (blockType === 'block1') showBlock1Instructions(blockNum);
      else showBlock2Instructions(blockNum);
    }

    function showBlock1Instructions(blockNumber) {
      const inst = document.getElementById('instructions-screen');
      inst.style.display = 'block';
      inst.innerHTML = `
        <h2>Experiment Instructions (for both blocks)</h2>
        <p>In this experiment, you will be presented with sets of cities and their distances from one another. Your goal is to find the shortest possible route that visits each city exactly once and returns to the original city.</p>

        <p style="font-size:1.15rem;"><strong>Importantly, as you are solving the problems, try to say out loud everything that goes through your mind.</strong></p>
        <p style="font-size:1.15rem;"><strong>If you are silent for a long period of time, we will send you a reminder to speak your thoughts aloud.</strong></p>

        <p>There will be ${N} problems in each block.</p>
        <div style="text-align:center;margin-top:24px;">
          <button id="begin-block-btn" style="padding:10px 20px;">Continue to Practice Trial</button>
        </div>
      `;
      document.getElementById('begin-block-btn').addEventListener('click', () => {
        showBlock1RuleCheck(blockNumber);
      });
    }

    // Rule check (retained)
    function showBlock1RuleCheck(blockNumber) {
      // Hide the instructions panel and show the main task container
      const inst = document.getElementById('instructions-screen');
      inst.style.display = 'none';

      const container = document.getElementById('task-ui');
      container.style.display = 'flex';

      // Left-column text (practice-specific)
      const leftHTML = `
        <div class="rules-text">
          <h3>Example Trial (Practice)</h3>
          <p><strong>Instructions: </strong>Your goal is to find the shortest possible route that visits each city exactly once and returns to the original city. Test out paths to find the shortest route by selecting cities from drop-down menus and entering the distances between the cities in the boxes below. 
          <p>You can view the total distance for a path by clicking the ‘Sum’ button. Once you press the Sum button, the path and its total distance are frozen. Then, <strong>you can make a new path</strong> by clicking the button in the top right. You will be able to see all paths you try. To indicate your final response, select the shortest path (by selecting one of the Path buttons) and click 'Continue'.</p>
          <p><strong>Importantly, as you are solving the problem, try to say out loud everything that goes through your mind.</strong></p>
          <p>Once you feel comfortable with the controls and have selected a Final Path, press <strong>Continue</strong> to begin the experiment.</p>
        </div>
      `;

      // Shared options (same as the experimental blocks)
      const cityOptions = ['City A','City B','City C']
        .map(c => `<option value="${c}">${c}</option>`).join('');
      const blank = `<option value="" selected disabled hidden></option>`;

      // Candidate Paths section
      const candidateSectionHTML = `
        <div id="candidate-section" class="candidate-section" style="margin-bottom:16px;">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; font-weight:600;">
            <h4 style="margin:0;">Select Paths and Enter Distances (sums are computed)</h4>
            <button id="add-candidate" type="button" class="add-candidate">+ Click to add a Path</button>
          </div>
          <div id="candidate-list" class="candidate-list" style="display:flex; flex-direction:column; gap:8px;"></div>
        </div>
      `;

      // Lay out the two columns just like the experimental blocks
      container.innerHTML = `
        <div class="left-column">${leftHTML}</div>
        <div class="right-column">
          ${candidateSectionHTML}
          <div id="completion-warning" style="margin:8px 0; font-size:0.9rem; color:#42a5f5;"></div>
          <div class="center">
            <button id="block1-check-continue-btn" class="done-button" disabled>Continue (Begin Experiment)</button>
          </div>
        </div>
      `;

      // Practice distance matrix (4 cities), rendered like the trial tables
      const practiceCities = ['City A', 'City B', 'City C'];
      const practiceMatrix = [[0, 2, 7], [2, 0, 6], [7, 6, 0]];

      // Append under the left-column instructions
      const leftCol = container.querySelector('.left-column');
      const host = document.createElement('div');
      host.id = 'practice-distance-table';
      host.style.marginTop = '12px';

      const title = document.createElement('h4');
      title.textContent = 'Distances Between Cities:';
      title.style.margin = '0 0 8px 0';   // match styling of other section titles
      leftCol.appendChild(title);

      leftCol.appendChild(host);

      // Uses the same formatting/indexing as block1/block2
      renderDistanceTable(host, practiceCities, practiceMatrix);

      // Enforce 1–10 on the four distance inputs
      const clamp1to10 = (val) => {
        if (val === '') return '';
        let n = parseInt(val, 10);
        if (Number.isNaN(n)) return '';
        if (n < 1) n = 1;
        if (n > 10) n = 10;
        return String(n);
      };

      // ---------- Candidate Paths logic (same behavior as trials) ----------
      const list = container.querySelector('#candidate-list');
      let candidateCount = 0;

      function addCandidatePath() {
        candidateCount += 1;
        const row = document.createElement('div');
        row.className = 'candidate-row';
        row.dataset.index = String(candidateCount);

        // 5 selects (City 1..4 + return)
        const topSelects = [1,2,3,4].map(i => {
          if (i === 1 || i === 4) {
            // Force City A, non-editable
            return `<select id="cand-${candidateCount}-${i}" class="candidate-select" 
                      style="grid-column:${2*i}; width:60px;" disabled>
                      <option value="City A" selected>City A</option>
                    </select>`;
          } else {
            // Middle cities remain editable
            return `<select id="cand-${candidateCount}-${i}" class="candidate-select" 
                      style="grid-column:${2*i}; width:60px;">${blank}${cityOptions}</select>`;
          }
        }).join('');

        const bottomDistances = [1,2,3].map(i =>
          `<input id="cand-${candidateCount}-d${i}" class="cand-distance-input" maxlength="2" style="grid-column:${2*i+1}; grid-row:2;" />`
        ).join('');

        row.innerHTML = `
          <div class="path-grid" style="width:100%;">
            <span class="path-label"
                  style="grid-column:1; grid-row:1; font-weight:600; display:inline-flex; align-items:center; gap:8px;">
              <input type="radio" class="final-pick" value="${candidateCount}"
                    disabled style="display:none;" aria-label="Choose Path ${candidateCount}" />
              Path ${candidateCount}
            </span>
            ${topSelects}
            <div class="cand-distance-wrap" style="grid-column:11; display:flex; flex-direction:column; align-items:flex-end; gap:4px; justify-self:end;">
              <label for="cand-${candidateCount}-distance" style="font-weight:600;">Sum</label>
              <input id="cand-${candidateCount}-distance"
                    inputmode="numeric"
                    pattern="[1-9][0-9]*"
                    aria-label="Candidate Total Distance (auto from segment distances)"
                    placeholder="auto"
                    style="width:20px; padding:6px 8px;" />
            </div>

            <span class="dist-label" style="grid-column:1; grid-row:2; font-weight:600;">Distances</span>
            ${bottomDistances}
          </div>
        `;

        list.appendChild(row);
        attachAutoSumForCandidateRow(row);
      }

      container.querySelector('#add-candidate').addEventListener('click', addCandidatePath);
      // Start with one candidate row
      addCandidatePath();

      // ---------- Gating for Continue (must choose a final-pick) ----------
      function finalPickSelected() {
        return !!container.querySelector('#candidate-section .final-pick:checked');
      }

      function updateContinueState() {
        const ok = finalPickSelected();
        const warn = container.querySelector('#completion-warning');
        container.querySelector('#block1-check-continue-btn').disabled = !ok;
        warn.textContent = ok ? '' :
          'Please choose your final path before continuing.';
      }

      // Watch any interaction inside candidate area (includes radio clicks)
      const candSection = container.querySelector('#candidate-section');
      ['input', 'change','click'].forEach(evt =>
        candSection.addEventListener(evt, updateContinueState)
      );
      updateContinueState();

      const continueBtn = container.querySelector('#block1-check-continue-btn');
      continueBtn.addEventListener('click', () => {
        if (!finalPickSelected()) { showError('Select your final path to continue.'); return; }
        startBlock(); // proceed to the first real trial
      });
    }



    function showBlock2Instructions(blockNumber) {
      const inst = document.getElementById('instructions-screen');
      inst.style.display = 'block';
      inst.innerHTML = `
        <h2>Please take a brief rest before continuing to Block #${blockNumber}</h2>
        <p>In this block, you will continue solving shortest-path style problems.</p>
        <p>As you solve the problems, please continue to describe your thought process out loud.</p>
        <p>There will be ${N} problems in this block.</p>
        <div style="text-align:center;margin-top:24px;">
          <button id="begin-block-btn" style="padding:10px 20px;">Begin block</button>
        </div>
      `;
      document.getElementById('begin-block-btn').addEventListener('click', () => {
        inst.style.display = 'none';
        startBlock();
      });
    }

    // --------------------------------------
    // BLOCK & TRIAL FLOW
    // --------------------------------------
    function startBlock() {
      trialIndex = 0;
      document.getElementById('task-ui').style.display = 'flex';
      loadTrial();
    }

    function loadTrial() {
      const blockNum = blockIndex + 1;
      const problemNum = trialIndex + 1;
      const type = blocks[blockIndex];
      currentPrompt = (type === 'block1' ? block1Prompts : block2Prompts)[trialIndex];
      currentState = structuredClone(blockData[type][trialIndex]);
      userActions = [];
      problemStartTime = Date.now();
      startRecording(blockNum, problemNum);
      VoiceFeedback.start();
      const numCities = (currentPrompt?.cities || []).length;
      const limitMs   = getTrialLimitMsFromCities(numCities);
      renderUI(type, limitMs);
      trialActive = true;            // mark trial as running
      startTrialTimer(limitMs);  // start city-based countdown
    }

    // --------------------------------------
    // RENDERING — block1/block2
    // --------------------------------------
    function renderUI(type, limitMs) {
    const container = document.getElementById('task-ui');

    // Left column instructions (unchanged)
    // Left column = instructions + the selected problem prompt (HTML)
    const instructionsHTML = `
      <div class="rules-text">
        <h3>Instructions</h3>
        <p>Your goal is to find the shortest possible route that visits each city exactly once and returns to the original city.</p>
        <p>Report the shortest path by selecting cities from drop-down menus and entering distances between cities below.</p>
        <p>You can view the total distance for a path by clicking the ‘Sum’ button</p>
      </div>
      <div id="problem-prompt" style="margin-top:12px;">${currentPrompt?.prompt || ''}
      </div>
      <p><strong>Importantly, as you are solving the problem, try to say out loud everything that goes through your mind.</strong></p>
    `;    

    // Shared options (use stimulus cities if present; default to 5)
    const cities = currentPrompt?.cities || ['City A', 'City B', 'City C','City D','City E'];
    const cityOptions = cities.map(c => `<option value="${c}">${c}</option>`).join('');

    const blank = `<option value="" selected disabled hidden></option>`;


    // Small helper to render a run of <select> elements
    function renderPathSelects(prefix, cssClass, count) {
      return Array.from({ length: count }, (_, i) =>
        `<select id="${prefix}-${i + 1}" class="${cssClass}">${blank}${cityOptions}</select>`
      ).join('');
    }

    // Candidate Paths section + button
    const candidateSectionHTML = `
      <div id="candidate-section" class="candidate-section" style="margin-bottom:16px;">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
          <h4 style="margin:0;">Select Paths and Enter Distances (sums are computed)</h4>
          <button id="add-candidate" type="button" class="add-candidate">+ Click to add a Path</button>
        </div>
        <div id="candidate-list" class="candidate-list" style="display:flex; flex-direction:column; gap:8px;"></div>
      </div>
    `;

    // How many stops to render (N cities + return to start)
    const numCities = cities.length;
    const numStops  = numCities + 1;

    // Build a responsive grid: [label] | S1 D1 S2 D2 ... S(N) D(N) S(N+1) | [total]
    const midCols = 2 * numStops - 1; // alternating selects & distance inputs


    // Render columns
    container.innerHTML = `
      <div class="left-column">${instructionsHTML}</div>
      <div class="right-column">
        <div id="trial-timer" class="trial-timer" role="timer" aria-live="polite" title="Time remaining">
          ${formatClock(limitMs)}
        </div>
        ${candidateSectionHTML}
        <div id="completion-warning" style="margin:8px 0; font-size:0.9rem; color:#42a5f5;"></div>
        <div class="center">
          <button id="done-button" class="done-button" disabled>Continue</button>
        </div>
      </div>
    `;

    const candSection = container.querySelector('#candidate-section');
    candSection.setAttribute('data-candidates', '');
    candSection.setAttribute('data-trial-id', `${blockIndex+1}-${trialIndex+1}`);

    // clear per-trial radio caches on the *trial container*, not body
    delete candSection.dataset.finalPickPrev;
    delete candSection.dataset.finalPickGroup;

    // Append distance table under the prompt text (left column)
    const promptEl = container.querySelector('#problem-prompt');
    if (promptEl && currentPrompt?.matrix) {
      renderDistanceTable(promptEl, cities, currentPrompt.matrix);
    }
    
    const doneBtn = container.querySelector('#done-button');
    doneBtn.addEventListener('click', () => {
      if (!finalPickSelected()) { showError('Select your final path to continue.'); return; }
      endTrial('user');
    });

    // ---------- Done gating (must choose a final-pick) ----------
    function finalPickSelected() {
      return !!container.querySelector('#candidate-section .final-pick:checked');
    }

    function updateDoneState() {
      const ok = finalPickSelected();
      const warn = container.querySelector('#completion-warning');
      container.querySelector('#done-button').disabled = !ok;
      warn.textContent = ok ? '' :
        'Please choose your final path before continuing.';
    }

    ['input','change','click'].forEach(evt =>
      candSection.addEventListener(evt, updateDoneState)
    );
    updateDoneState();


    // ---------- Candidate Paths logic ----------
    const list = container.querySelector('#candidate-list');
    let candidateCount = 0;

    function addCandidatePath() {
      candidateCount += 1;

      // Dynamic grid: label | S D S D ... S | total
      const hops = numStops - 1;         // number of distances
      const selFr = 1.4;                 // widen selects
      const distFr = 0.5;                // narrow distances
      const candColsCSS =
        `auto minmax(0,${selFr}fr) repeat(${hops}, minmax(0,${distFr}fr) minmax(0,${selFr}fr)) auto`;

      const topSelects = Array.from({ length: numStops }, (_, i) => {
        const col = 2 * (i + 1);
        if (i === 0 || i === numStops - 1) {
          return `<select id="cand-${candidateCount}-${i+1}" class="candidate-select" 
                    style="grid-column:${col}; width:50px;" disabled>
                    <option value="City A" selected>City A</option>
                  </select>`;
        } else {
          return `<select id="cand-${candidateCount}-${i+1}" class="candidate-select" 
                    style="grid-column:${col}; width:50px;">
                    ${blank}${cityOptions}
                  </select>`;
                }
      }).join('');


      const bottomDistances = Array.from({ length: numStops - 1 }, (_, i) => {
        const col = 2 * (i + 1) + 1;
        return `<input class="cand-distance-input" maxlength="2"
                      style="grid-column:${col}; grid-row:2; justify-self:center; width:35px; text-align:center;" />`;
      }).join('');

      const row = document.createElement('div');
      row.className = 'candidate-row';
      row.dataset.index = String(candidateCount);
      row.innerHTML = `
        <div class="path-grid" style="
          display:grid;
          grid-template-columns:${candColsCSS};
          column-gap:4px; row-gap:8px; align-items:center; width:100%;
        ">
          <span class="path-label"
                style="grid-column:1; grid-row:1; font-weight:600; display:inline-flex; align-items:center; gap:6px; font-size:0.9rem;">
            <input type="radio" class="final-pick" value="${candidateCount}"
                  disabled style="display:none;" aria-label="Choose Path ${candidateCount}" />
            Path ${candidateCount}
          </span>
          ${topSelects}
          <div class="cand-distance-wrap"
              style="grid-column:${2 * numStops + 1}; display:flex; flex-direction:column; align-items:flex-end; gap:3px; justify-self:end;">
            <label for="cand-${candidateCount}-distance" style="font-weight:600; font-size:0.85rem;">Sum</label>
            <input id="cand-${candidateCount}-distance" inputmode="numeric" pattern="[1-9][0-9]*" placeholder="auto"
                  style="width:35px; padding:4px 6px; font-size:0.9rem;" />
          </div>

          <span class="dist-label" style="grid-column:1; grid-row:2; font-weight:600; font-size:0.85rem;">Distances</span>
          ${bottomDistances}
        </div>
      `;

      list.appendChild(row);

      // Auto-sum for this candidate row
      attachAutoSumForCandidateRow(
        row,
        `#cand-${candidateCount}-distance`,
        `.cand-distance-input`
      );
    }

    // --- Wire up the Add Candidate button once, after the function is defined ---
    const addBtn = container.querySelector('#add-candidate');
    if (addBtn) {
      addBtn.addEventListener('click', addCandidatePath);
      addCandidatePath(); // start with one blank candidate row
    }
  }

    function showInBlockRest(blockType) {
      const inst = document.getElementById('instructions-screen');
      const ui   = document.getElementById('task-ui');

      // hide the trial UI so nothing interactive (or audio) runs
      ui.style.display = 'none';

      inst.style.display = 'block';
      inst.innerHTML = `
        <h2>Short break</h2>
        <p>Please take a short break and press the 'Continue' button below when you are ready.</p>
        <div style="text-align:center;margin-top:24px;">
          <button id="inblock-continue" style="padding:10px 20px;">Continue</button>
        </div>
      `;

      document.getElementById('inblock-continue').addEventListener('click', () => {
        inst.style.display = 'none';
        ui.style.display   = 'flex';
        inBlockRestShown[blockType] = true;
        // Resume with the *next* trial; loadTrial() will start recording again.
        loadTrial();  // startRecording() happens inside loadTrial()
      }, { once: true });
    }
    
    // --------------------------------------
    // END OF TRIAL / BLOCK / STUDY
    // --------------------------------------
    function endTrial(reason = 'user') {
      if (!trialActive) return; // prevent double-firing
      trialActive = false;
      clearTrialTimer();
      
      const trialEndTs = Date.now();

      stopRecording(async () => {
        await VoiceFeedback.stop();
      
      const type = blocks[blockIndex];

      // In endTrial(), when copying candidate rows into userActions:
      readCandidatePathsFromUI().forEach(c => {
        userActions.push({
          type: 'candidate-path',
          index: c.index,
          path: c.path,
          segmentDistances: c.segmentDistances, // <-- NEW
          totalDistance: c.totalDistance,
          capturedAt: (c.sumCapturedAt ?? trialEndTs)
        });
      });

      // 2) Find the most recent "select-final" event in THIS trial
      //    (reverse-scan is fast and simple; add the trialIndex check if userActions spans multiple trials)
      const lastSelectFinalTs = (() => {
        for (let i = userActions.length - 1; i >= 0; i--) {
          const a = userActions[i];
          if (a.type === "select-final"/* && a.trialIndex === (trialIndex + 1) */) {
            return a.timestamp;
          }
        }
        return null;
      })();

      // 3) Snapshot the final pick using the select-final timestamp (or end-of-trial if never selected)
      const finalPick = readFinalPickFromUI();
      if (finalPick) {
        userActions.push({
          type: "final-pick",
          index: finalPick.index,
          path: finalPick.path,
          segmentDistances: finalPick.segmentDistances,
          totalDistance: finalPick.totalDistance,
          capturedAt: (lastSelectFinalTs ?? trialEndTs)
        });
      }
        allProblemLogs.push({
          blockType: type,
          trialIndex: trialIndex + 1,
          promptId: currentPrompt?.id || null,
          opt_paths: (currentPrompt?.opt_paths_list || []).map(p => p.join('-')),
          opt_cost_list:  currentPrompt?.opt_cost_list  ?? null,
          is_nn_optimal:  typeof currentPrompt?.is_nn_optimal !== "undefined"
                    ? currentPrompt.is_nn_optimal : null,
          actions: userActions,
          startTime: problemStartTime,
          endTime: trialEndTs,
          endedBy: reason            // <-- add this line
        });

        // ... inside endTrial() after you push logs ...
        trialIndex++;

        // NEW: if we just finished the i-th trial in this block, show rest once.
        if (trialIndex === INBLOCK_REST_AFTER && !inBlockRestShown[type] && trialIndex < N) {
          showInBlockRest(type);
          return; // important: don't fall through to loadTrial()/block transition
        }

        // existing flow:
        if (trialIndex < N) {
          loadTrial();
        } else {
          blockIndex++;
          if (blockIndex < 2) {
            document.getElementById('task-ui').style.display = 'none';
            loadBlock();
          } else {
            showInternalImagerySurvey();   // run the new 12-item survey first
                    }
        }
      });
    }


    async function finishStudy() {
      if (document.fullscreenElement) document.exitFullscreen().catch(()=>{});
      document.getElementById('task-ui').style.display = 'none';
      const mount = document.getElementById('instructions-screen');
      if (mount) {
        mount.style.display = 'none';
        mount.classList.remove('wide');
        // optional: mount.innerHTML = '';
      }

      const end = document.getElementById('end-screen');
      const puzzleData = { participantData, puzzleLogs: allProblemLogs, internalImagerySurvey: (window.internalImagerySurvey || null), preFinalSurvey: (window.preFinalSurvey || null), finalSurvey: finalSurveyData };
      const timestamp = Date.now();
      const participantId = `P_${timestamp}_${Math.random().toString(36).substr(2, 9)}`;

      try {
        // Save to Firebase
        try {
          // 1. Upload audio files to Storage
          for (const {block, trial, blob} of audioChunks) {
            const audioFileName = `audio/${participantId}/block${block}_problem${trial}.webm`;
            const audioRef = ref(storage, audioFileName);
            await uploadBytes(audioRef, blob);
          }

          // 2. Save experiment data to Firestore
          const experimentData = {
            participantId,
            timestamp: serverTimestamp(),
            clientTimestamp: timestamp,
            participantData,
            puzzleLogs: allProblemLogs,
            internalImagerySurvey: (window.internalImagerySurvey || null),
            preFinalSurvey: (window.preFinalSurvey || null),
            finalSurvey: finalSurveyData,
            audioFileCount: audioChunks.length,
            userAgent: navigator.userAgent
          };

          const docRef = await addDoc(collection(db, 'experiments'), experimentData);
          console.log('Data saved to Firebase with ID:', docRef.id);

        } catch (firebaseError) {
          console.error('Firebase save failed:', firebaseError);
          showError('Could not save to Firebase; will save locally instead.');
        }

        // Always create local ZIP as backup
        const zip = new JSZip();
        zip.file("puzzle_data.json", JSON.stringify(puzzleData, null, 2));
        if (window.internalImagerySurvey) {
          zip.file("internal_imagery_survey.json", JSON.stringify(window.internalImagerySurvey, null, 2));
        }
        if (window.preFinalSurvey) {
          zip.file("pre_final_survey.json", JSON.stringify(window.preFinalSurvey, null, 2));
        }
        if (finalSurveyData) {
          zip.file("final_survey.json", JSON.stringify(finalSurveyData, null, 2));
        }
        audioChunks.forEach(({ block, trial, blob }) => {
          zip.file(`block${block}_problem${trial}.webm`, blob);
        });
        const zipBlob = await zip.generateAsync({ type: "blob" });
        saveAs(zipBlob, "combined_task_data_with_audio.zip");

      } catch (err) {
        console.error('Error in finishStudy:', err);
        showError('Some data saving failed, but study is complete.');
      } finally {
        // Always show end screen
        end.style.display = 'block';
        end.setAttribute('tabindex', '-1');
        end.focus();
        document.addEventListener('keydown', onEndScreenKey, { once: true });
      }
    }

    // Replace your onEndScreenKey with this version
    function onEndScreenKey() {
      document.removeEventListener('keydown', onEndScreenKey);
      const end = document.getElementById('end-screen');
      end.innerHTML = `
        <p style="margin-bottom:16px; font-size:18px;">
          Thank you for participating in our study!
        </p>
        <p style="font-size:14px; opacity:.8;">
          Access the completion code here: https://app.prolific.com/submissions/complete?cc=CJ7Q9EJC
        </p>
      `;
    }

    // --------------------------------------
    // START
    // --------------------------------------
    startIntro();
  </script>
  <footer class="site-footer">
    <div class="footer-content">
      <a href="https://support.microsoft.com/contactus">Contact Us</a>
      <a href="https://go.microsoft.com/fwlink/?LinkId=521839">Privacy & Cookies</a>
      <a href="https://go.microsoft.com/fwlink/?LinkID=246338">Terms of Use</a>
      <a href="https://go.microsoft.com/fwlink/?linkid=2196228%20">Trademarks</a>
      <span>© 2025 Microsoft</span>
    </div>
  </footer>
</body>
</html>
